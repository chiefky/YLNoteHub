# 1、Crash

> 引自：https://www.jianshu.com/p/3f6775c02257

## 1.1 常见的Crash类型有哪些？

>根据Crash 的不同来源，Crash 分为以下三类：
>
>- Mach 异常
>
>  最底层的内核级异常。用户态的开发者可以直接通过Mach API设置thread，task，host的异常端口，来捕获Mach异常。
>
>- Unix 信号
>
>  又称BSD 信号，如果开发者没有捕获Mach异常，则会被host层的方法ux_exception()将异常转换为对应的UNIX信号，并通过方法threadsignal()将信号投递到出错线程。可以通过方法signal(x, SignalHandler)来捕获signal。
>
>- NSException
>
>  应用级异常，它是未被捕获的Objective-C异常，导致程序向自身发送了SIGABRT信号而崩溃，是app自己可控的，对于未捕获的Objective-C异常，是可以通过try catch来捕获的，或者通过NSSetUncaughtExceptionHandler()机制来捕获。

## 1.2 分别用什么方式可以捕获？

 ### 1. 如何捕获Mach异常？

><img src="/Users/tangh/yuki/博客/文章仓库/YLNoteHub/content/All/image/crash-mach_1.jpeg" alt="img" style="zoom:80%;" />
>
>参考上图，主要的流程是：新建一个监控线程，在监控线程中监听 Mach 异常并处理异常信息。主要的步奏如下图：
>
><img src="/Users/tangh/yuki/博客/文章仓库/YLNoteHub/content/All/image/crash-mach_2.png" alt="内核 crash 手机的流程" style="zoom:120%;" />
>
>具体代码如下:
>
>```c++
>static mach_port_t server_port;
>static void *exc_handler(void *ignored);
>
>//判断是否 Xcode 联调
>bool ksdebug_isBeingTraced(void)
>{
>struct kinfo_proc procInfo;
>size_t structSize = sizeof(procInfo);
>int mib[] = {CTL_KERN, KERN_PROC, KERN_PROC_PID, getpid()};
>
>if(sysctl(mib, sizeof(mib)/sizeof(*mib), &procInfo, &structSize, NULL, 0) != 0)
>{
>    return false;
>}
>
>return (procInfo.kp_proc.p_flag & P_TRACED) != 0;
>}
>
>#define EXC_UNIX_BAD_SYSCALL 0x10000 /* SIGSYS */
>#define EXC_UNIX_BAD_PIPE    0x10001 /* SIGPIPE */
>#define EXC_UNIX_ABORT       0x10002 /* SIGABRT */
>static int signalForMachException(exception_type_t exception, mach_exception_code_t code)
>{
>switch(exception)
>{
>    case EXC_ARITHMETIC:
>        return SIGFPE;
>    case EXC_BAD_ACCESS:
>        return code == KERN_INVALID_ADDRESS ? SIGSEGV : SIGBUS;
>    case EXC_BAD_INSTRUCTION:
>        return SIGILL;
>    case EXC_BREAKPOINT:
>        return SIGTRAP;
>    case EXC_EMULATION:
>        return SIGEMT;
>    case EXC_SOFTWARE:
>    {
>        switch (code)
>        {
>            case EXC_UNIX_BAD_SYSCALL:
>                return SIGSYS;
>            case EXC_UNIX_BAD_PIPE:
>                return SIGPIPE;
>            case EXC_UNIX_ABORT:
>                return SIGABRT;
>            case EXC_SOFT_SIGNAL:
>                return SIGKILL;
>        }
>        break;
>    }
>}
>return 0;
>}
>
>static NSString *stringForMachException(exception_type_t exception) {
>switch(exception)
>{
>    case EXC_ARITHMETIC:
>        return @"EXC_ARITHMETIC";
>    case EXC_BAD_ACCESS:
>        return @"EXC_BAD_ACCESS";
>    case EXC_BAD_INSTRUCTION:
>        return @"EXC_BAD_INSTRUCTION";
>    case EXC_BREAKPOINT:
>        return @"EXC_BREAKPOINT";
>    case EXC_EMULATION:
>        return @"EXC_EMULATION";
>    case EXC_SOFTWARE:
>    {
>        return @"EXC_SOFTWARE";
>        break;
>    }
>}
>return 0;
>}
>
>void installExceptionHandler() {
>if (ksdebug_isBeingTraced()) {
>    // 当前正在调试状态, 不启动 mach 监听
>    return ;
>}
>kern_return_t kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &server_port);
>assert(kr == KERN_SUCCESS);
>
>kern_return_t rc = 0;
>exception_mask_t excMask = EXC_MASK_BAD_ACCESS |
>EXC_MASK_BAD_INSTRUCTION |
>EXC_MASK_ARITHMETIC |
>EXC_MASK_SOFTWARE |
>EXC_MASK_BREAKPOINT;
>
>rc = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &server_port);
>if (rc != KERN_SUCCESS) {
>    fprintf(stderr, "------->Fail to allocate exception port\\\\\\\\n");
>    return;
>}
>
>rc = mach_port_insert_right(mach_task_self(), server_port, server_port, MACH_MSG_TYPE_MAKE_SEND);
>if (rc != KERN_SUCCESS) {
>    fprintf(stderr, "-------->Fail to insert right");
>    return;
>}
>
>rc = thread_set_exception_ports(mach_thread_self(), excMask, server_port, EXCEPTION_DEFAULT, MACHINE_THREAD_STATE);
>if (rc != KERN_SUCCESS) {
>    fprintf(stderr, "-------->Fail to  set exception\\\\\\\\n");
>    return;
>}
>
>//建立监听线程
>pthread_t thread;
>pthread_create(&thread, NULL, exc_handler, NULL);
>}
>
>static void *exc_handler(void *ignored) {
>// Exception handler – runs a message loop. Refactored into a standalone function
>// so as to allow easy insertion into a thread (can be in same program or different)
>mach_msg_return_t rc;
>fprintf(stderr, "Exc handler listening\\\\\\\\n");
>// The exception message, straight from mach/exc.defs (following MIG processing) // copied here for ease of reference.
>typedef struct {
>    mach_msg_header_t Head;
>    /* start of the kernel processed data */
>    mach_msg_body_t msgh_body;
>    mach_msg_port_descriptor_t thread;
>    mach_msg_port_descriptor_t task;
>    /* end of the kernel processed data */
>    NDR_record_t NDR;
>    exception_type_t exception;
>    mach_msg_type_number_t codeCnt;
>    integer_t code[2];
>    int flavor;
>    mach_msg_type_number_t old_stateCnt;
>    natural_t old_state[144];
>} Request;
>
>Request exc;
>
>struct rep_msg {
>    mach_msg_header_t Head;
>    NDR_record_t NDR;
>    kern_return_t RetCode;
>} rep_msg;
>
>for(;;) {
>    // Message Loop: Block indefinitely until we get a message, which has to be
>    // 这里会阻塞，直到接收到exception message，或者线程被中断。
>    // an exception message (nothing else arrives on an exception port)
>    rc = mach_msg( &exc.Head,
>                  MACH_RCV_MSG|MACH_RCV_LARGE,
>                  0,
>                  sizeof(Request),
>                  server_port, // Remember this was global – that's why.
>                  MACH_MSG_TIMEOUT_NONE,
>                  MACH_PORT_NULL);
>
>        if(rc != MACH_MSG_SUCCESS) {
>        /*... */
>        break ;
>    };
>
>        //Mach Exception 类型
>    NSMutableString *crashInfo = [NSMutableString stringWithFormat:@"mach exception:%@ %@\n\n",stringForMachException(exc.exception), stringForSignal(signalForMachException(exc.exception, exc.code[0]))];
>
>        rep_msg.Head = exc.Head;
>    rep_msg.NDR = exc.NDR;
>    rep_msg.RetCode = KERN_FAILURE;
>
>        kern_return_t result;
>    if (rc == MACH_MSG_SUCCESS) {
>        result = mach_msg(&rep_msg.Head,
>                          MACH_SEND_MSG,
>                          sizeof (rep_msg),
>                          0,
>                          MACH_PORT_NULL,
>                          MACH_MSG_TIMEOUT_NONE,
>                          MACH_PORT_NULL);
>    }
>    //移除其他 Crash 监听, 防止死锁
>    NSSetUncaughtExceptionHandler(NULL);
>    signal(SIGHUP, SIG_DFL);
>    signal(SIGINT, SIG_DFL);
>    signal(SIGQUIT, SIG_DFL);
>    signal(SIGABRT, SIG_DFL);
>    signal(SIGILL, SIG_DFL);
>    signal(SIGSEGV, SIG_DFL);
>    signal(SIGFPE, SIG_DFL);
>    signal(SIGBUS, SIG_DFL);
>    signal(SIGPIPE, SIG_DFL);
>}
>
>return  NULL;
>}
>```
>
>监听 Mach 异常需要注意:
>
>- 避免在 Xcode 联调时监听
>
> 原因是我们监听了`EXC_BREAKPOINT`这类型的`Exception`，一旦启动 app 联调后， 会立即触发`EXC_BREAKPOINT`。而这段代码处理完后，会进入下一个循环等待，可主线程这是还等着消息处理结果，这就造成等待死锁。

### 2. 如何捕捉 Unix 信号？

> 一般来说我们需要捕捉以下信号:
>
> ```c
> static const int g_fatalSignals[] =
> {
>  SIGABRT,
>  SIGBUS,
>  SIGFPE,
>  SIGILL,
>  SIGPIPE,
>  SIGSEGV,
>  SIGSYS,
>  SIGTRAP,
> };
> ```
>
> 而要捕捉 Unix 信号，比 Mach 异常容易多了
>
> ```objective-c
> void installSignalHandler() {
>      signal(SIGABRT, handleSignalException);
>  //...等等其他需要监听的 Signal
> }
> void handleSignalException(int signal) {
>  //打印堆栈
>  NSMutableString * crashInfo = [[NSMutableString alloc]init];
>  [crashInfo appendString:[NSString stringWithFormat:@"signal:%d\n",signal]];
>  [crashInfo appendString:@"Stack:\n"];
>  void* callstack[128];
>  int i, frames = backtrace(callstack, 128);
>  char** strs = backtrace_symbols(callstack, frames);
>  for (i = 0; i <frames; ++i) {
>      [crashInfo appendFormat:@"%s\n", strs[I]];
>  }
>  NSLog(@"%@", crashInfo);
>  //移除其他 Crash 监听, 防止死锁
>  NSSetUncaughtExceptionHandler(NULL);
>  signal(SIGHUP, SIG_DFL);
>  signal(SIGINT, SIG_DFL);
>  signal(SIGQUIT, SIG_DFL);
>  signal(SIGABRT, SIG_DFL);
>  signal(SIGILL, SIG_DFL);
>  signal(SIGSEGV, SIG_DFL);
>  signal(SIGFPE, SIG_DFL);
>  signal(SIGBUS, SIG_DFL);
>  signal(SIGPIPE, SIG_DFL);
> }
> ```
>
> ## 备用信号栈
>
> 上面这个方法可以监控到大部分的 Signal 异常，但是我们会发现如果遇到死循环这类的Crash，就没法监控了。原因是一般情况下，信号处理函数被调用时，内核会在进程的栈上为其创建一个栈帧。但这里就会有一个问题，如果之前栈的增长**达到了栈的最大长度**，或是栈没有达到最大长度但也比较接近，那么就会导致信号处理函数不能得到足够栈帧分配。
>
> 为了解决这个问题，我们需要设定一个**可选的栈帧**：
>
> 1. 申请一块内存空间作为可选的信号处理函数栈使用
> 2. 使用 sigaltstack 函数通知系统可选的信号处理栈帧的存在及其位置
> 3. 当使用 sigaction 函数建立一个信号处理函数时，通过指定 SA_ONSTACK 标志通知系统这个信号处理函数应该在可选的栈帧上面执行注册的信号处理函数
>
> 前面监听 Unix 信号的代码，改动一下：
>
> 
>
> ```c
> void installSignalHandler() {
>         stack_t ss;
>     struct sigaction sa;
>     struct timespec req, rem;
>     long ret;
> 
>     ss.ss_flags = 0;
>     ss.ss_size = SIGSTKSZ;
>     ss.ss_sp = malloc(ss.ss_size);
>     sigaltstack(&ss, NULL);
> 
>     memset(&sa, 0, sizeof(sa));
>     sa.sa_handler = handleSignalException;
>     sa.sa_flags = SA_ONSTACK;
>     sigaction(SIGABRT, &sa, NULL);
> }
> ```

### 3. 如何捕获NSException？

>NSException 是应用级异常，是指 OC 代码运行过程由Objective-C 抛出的异常，基本上是代码运行过程中的逻辑错误。比如往 NSArray 中插入 nil 对象，或者用nil 初始化 NSURL 等。最简单区分一个异常是否 NSException 的方式是看这个异常能否被@trycatch 给捕获。
>
>## 常见的 NSException 场景
>
>- 非主线程刷新UI
>- NSInvalidArgumentException
>  非法参数异常(NSInvalidArgumentException)是 Objective – C 代码最常出现的错误，所以平时在写代码的时候，需要多加注意，加强对参数的检查，避免传入非法参数导致异常，其中尤以nil参数为甚。
>- NSRangeException
>  越界异常(NSRangeException)也是比较常出现的异常。
>- NSGenericException
>  NSGenericException这个异常最容易出现在foreach操作中，在for in循环中如果修改所遍历的数组，无论你是add或remove，都会出错 “for in”,它的内部遍历使用了类似 Iterator进行迭代遍历，一旦元素变动，之前的元素全部被失效，所以在foreach的循环当中，最好不要去进行元素的修改动作，若需要修改，循环改为for遍历，由于内部机制不同，不会产生修改后结果失效的问题。
>- NSInternalInconsistencyException
>  不一致导致出现的异常
>  比如NSDictionary当做NSMutableDictionary来使用，从他们内部的机理来说，就会产生一些错误
>  NSMutableDictionary *info = method return to NSDictionary type;
>  [info setObject:@“sxm” forKey:@”name”];
>  比如xib界面使用或者约束设置不当
>- NSFileHandleOperationException
>  处理文件时的一些异常，最常见的还是存储空间不足的问题，比如应用频繁的保存文档，缓存资料或者处理比较大的数据:
>  所以在文件处理里，需要考虑到手机存储空间的问题。
>- NSMallocException
>  这也是内存不足的问题，无法分配足够的内存空间
>  此外还有
>- KVO Crash
>  移除未注册的观察者
>  重复移除观察者
>  添加了观察者但是没有实现`-observeValueForKeyPath:ofObject:change:context:`方法
>  添加移除keypath=nil
>  添加移除observer=nil
>- unrecognized selector send to instance
>
>## 监听 NSException 异常
>
>NSException的监听也十分简单:
>
>```c
>void InstallUncaughtExceptionHandler(void) {
>   NSSetUncaughtExceptionHandler( &handleUncaughtException );
>}
>
>void handleUncaughtException(NSException *exception) {
>   NSString * crashInfo = [NSString stringWithFormat:@"yyyy Exception name：%@\nException reason：%@\nException stack：%@",[exception name], [exception reason], [exception callStackSymbols]];
>   NSLog(@"%@", crashInfo);
>}
>```
>
>需要注意的是，在监听处理的方法中，是**无法直接采集错误到堆栈**的。详情我同样会在下一篇的崩溃堆栈收集的文章中介绍。

# 2、私有Api

怎么调用私有Api？有什么问题吗？审核不过有什么办法？

## 2.1 怎么调用私有Api

* 直接调用法

  因为私有 API 没有暴露出来，编译会报错。可以添加匿名 `Category` 声明下私有方法。

  ```objc
  @interface UIView()
  -(id)recursiveDescription;
  @end
  ```

* 字符拼接

  借助 Objective-C 语言的动态特性，在运行时用 `performSelector` 执行拼接的 selector 方法：

* 代码混淆

  ```objc
  // statusBar
  NSData *data = [NSData dataWithBytes:(unsigned char[]){0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x42, 0x61, 0x72} length:9]; 
  NSString *key = [[NSString alloc] initWithData:data encoding:NSASCIIStringEncoding];
  ```

## 2.2 存在问题

可能无法过审

## 2.3 检测方法

###  方法1：符号表检查

用 `nm`、`otool` 等工具导出二进制包的函数符号表，以检查私有 API 的调用。

开源项目 [iOS-private-api-checker](https://github.com/NetEaseGame/iOS-private-api-checker) 以这种方式实现了对私有 API 调用的检查。

然而这种方法的缺点是，无法检测字符串拼接方法的私有 API 调用。

###  方法2：运行时分析

在审核人员运行 App 的同时，用 runtime 工具检测是否调用了私有 API。具体原理待补充。

这种方法的漏洞，当审核人员无法进入调用了私有 API 的功能时（通过后台下发配置文件控制功能入口），会有漏测的情况。

### 方法3：静态[代码分析](https://cloud.tencent.com/product/tcap?from=10680)

为检测字符串拼接法调用私有 API，受论文 [1] 启发，可以在对二进制文件反汇编结果的基础上，进行静态分析：

1. 找出动态调用 API 方法如 `performSelector:` ，以及调用对象的类
2. 检查参数，如果参数是拼接方法生成，推导求得拼接的结果
3. 根据 1 2 判断是否调用了私有 API

以私有 API 调用方法2 的代码为例，用 Hopper 对其反汇编，得到伪代码：

```js
void -[ViewController viewDidLoad](void * self, void * _cmd) {
    r31 = r31 - 0x60;
    *(r31 + 0x30) = r22;
    *(0x40 + r31) = r21;
    *(r31 + 0x40) = r20;
    *(0x50 + r31) = r19;
    *(r31 + 0x50) = r29;
    *(0x60 + r31) = r30;
    *(r31 + 0x28) = ___stack_chk_guard;
    *(r31 + 0x8) = self;
    *(r31 + 0x10) = 0x100008d38;
    [[r31 + 0x8 super] viewDidLoad];
    *(r31 + 0x18) = @"_private";
    *(0x28 + r31) = @"Method";
    r0 = [0x100008d28 arrayWithObjects:r31 + 0x18 count:0x2];
    r0 = [r0 retain];
    r20 = r0;
    r0 = [r0 componentsJoinedByString:@""];
    r0 = [r0 retain];
    [self performSelector:NSSelectorFromString(r0) withObject:zero_extend_64(0x0)];
    [r0 release];
    [r20 release];
    if (___stack_chk_guard != *(r31 + 0x28)) {
            __stack_chk_fail();
    }
    return;
}
```

可以看出，伪代码有着充分的信息，可以进行静态分析推导，判断代码片段是否调用了私有 API。

然而这种方法也有漏洞，拼接的字符串由[服务器](https://cloud.tencent.com/product/cvm?from=10680)下发，可以避开检查。

# 3、循环引用

## 3.1 造成循环引用的方式有哪些？

> 1. block
> 1. delegate
> 1. // Swift 方法嵌套

## 3.2 分别有什么解决方法？

> block内循环引用解决方法:
>
> > 1. 借助weak解决循环引用
> > 1. 借助__block解决循环引用
> > 1. "将强引用对象作为block参数传入"解决循环引用
> > 1. 借助NSProxy解决循环引用
>
> delegate造成循环引用解决方法：
>
> > delegate 使用weak修饰符修饰

## 3.3 NSTimer的循环引用一般用什么方式解决？

> 1. 自定义timer，使timer的target不直接使用vc；
>    注意：自定义timer与NSTimer间仍然存在强引用，需要在vc dealloc之前stop timer
>
> 2. 使用iOS10新增的`scheldueTimerWithBlock:`;
>    注意：
>
>    * block仍然会产生循环引用，block内使用weakSelf
>    * 持用 NSTimer 对象的类的方法中 -(void)dealloc 调用 NSTimer  的- (void)invalidate 方法；
>
> 3. 使用block，类似iOS新增的接口
>
>    ```objective-c
>    @implementation NSTimer (SafeBlock)
>    
>    + (instancetype)yl_ScheduledTimerWithTimeInterval:(NSTimeInterval)timeInterval repeats:(BOOL)repeats block:(void (^)(void))block {
>        return [NSTimer scheduledTimerWithTimeInterval:timeInterval target:self selector:@selector(handle:) userInfo:[block copy] repeats:repeats];
>    }
>    
>    + (void)handle:(NSTimer *)timer {
>        void(^block)(void) = timer.userInfo;
>        if (block) {
>            block();
>        }
>    }
>    
>    @end
>    ```
>
>    注意：同2
>
> 4. NSProxy虚基类的方式
>    ///使用NSProxy（其实是借助参数传递中间者+中间者弱持有self就可以解决，完全可以不用消息转发）（使用Proxy的原理是：1.添加了一个中间者Proxy；2.Proxy持有一个弱引用对象，也就是响应方法的目标对象；3. 借助消息转发机制将消息传递给目标对象）
>
>    注意：
>
>    *  持用 NSTimer 对象的类的方法中 -(void)dealloc 调用 NSTimer  的- (void)invalidate 方法；

# 4、NSProxy 了解吗？一般是用来做什么的？

> 

# 18、对象的引用计数一般存在什么地方？

> 经过优化的对象：
>
> 未经过优化的对象：

# 6、UIKit 与 Core Animation 了解吗？分别是用来做什么的？为什么要同时存在这两种框架？

> s
>
> 

# 20、应用的编译过程能说一下吗？针对某一个源文件的编译，它又经过哪几步呢？



# 8、能说一下使用xib过程遇到的问题吗？



# 22、能简单描述一下Https建立连接的过程吗？

# 10、说一下LRU算法的数据结构吧？针对LRU结构的常见操作，它们的时间复杂度分别是多少？（查询、插入、删除）

# 24、算法思路描述：两个子视图，寻找它们最近的共同父视图。

# 12、算法：检查两个单链表是否相交，如果相交返回相交节点。


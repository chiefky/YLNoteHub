## 1.常用的属性修饰符有哪些？分别做什么用？

### 常用属性修饰符：

* 原子性：atomic、nonatomic
* 读写权限：readwrite、readonly
* 内存管理权限： strong、copy、weak、assign、unsafe_unretained
* 指定方法名：setter=、getter= 

**Property的默认设置**

> * 基本数据类型：atomic, readwrite, assign
>
> * 对象类型：atomic, readwrite, strong
>
>   注意：考虑到代码可读性以及日常代码修改频率，规范的编码风格中关键词的顺序是：原子性、读写权限、内存管理语义、getter/getter。

### 用途：

#### 1.原子性

> 原子性：并发编程中确保其操作具备整体性，系统其它部分无法观察到中间步骤，只能看到操作前后的结果。
>
> atomic：原子性的，编译器会通过锁定机制确保setter和getter的完整性。
>
> nonatomic：非原子性的，不保证setter和getter的完整性。
>
> 区别：由于要保证操作完整，atomic速度比较慢，线程相对安全；nonatomic速度比较快，但是线程不安全。atomic也不是绝对的线程安全，当多个线程同时调用set和get时，就会导致获取的值不一样。由于锁定机制开销较大，一般iOS开发中会使用nonatomic，而macOS中使用atomic通常不会有性能瓶颈。
>
> 拓展：要想线程绝对安全，就要使用 @synchronized同步锁。但是由于同步锁有等待操作，会降低代码效率。为了兼顾线程安全和提升效率，可采用GCD并发队列进行优化改进。get使用同步派发，set使用异步栅栏。
>
> ```objective-c
> //同步锁
> - (NSString *)someString {
>     @synchronized(self) {
>         return _someString;
>     }
> }
> - (void)setSomeString:(NSString *)someString {
>     @synchronized(self) {
>         _someString = someString;
>     }
> }
> //并发队列
> _queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
> - (NSString *)someString {
>     __block NSString *localSomeString;
>     dispatch_sync(_queue, ^{
>         localSomeString = _someString;
>     });
>     return localSomeString;
> }
> - (void)setSomeString:(NSString *)someString {
>     dispatch_barrier_async(_queue, ^{
>         _someString = someString;
>     });
> }
> ```

#### 2. 读写权限

读写权限不写时默认为 readwrite 。一般可在 .h 里写成readonly，只对外提供读取，在 .m 的Extension中再设置为 readwrite 可进行写入。

#### **3. 内存管理语义**

**所有关键字：strong、copy、weak、assign、unsafe_unretained**

- strong：表示指向并拥有该对象。其修饰的对象引用计数会 +1 ，该对象只要引用计数不为 0 就不会销毁，强行置空可以销毁它。一般用于修饰对象类型、字符串和集合类的可变版本。
- copy：与strong类似，设置方法会拷贝一份副本。一般用于修饰字符串和集合类的不可变版， block用copy修饰。
- weak：表示指向但不拥有该对象。其修饰的对象引用计数不会增加，属性所指的对象遭到摧毁时属性值会清空。ARC环境下一般用于修饰可能会引起循环引用的对象，delegate用weak修饰，xib控件也用weak修饰。
- assign：主要用于修饰基本数据类型，如NSIteger、CGFloat等，这些数值主要存在于栈中。
- unsafe_unretained：与weak类似，但是销毁时不自动清空，容易形成野指针。

> 相关问题:
>
>   1. copy与strong区别 ?
>
> copy与strong：相同之处是用于修饰表示拥有关系的对象。不同之处是strong赋值是多个指针指向同一个地址，而copy的赋值是每次会在内存中复制一份对象，指针指向不同的地址。NSString、NSArray、NSDictionary等不可变对象用copy修饰，因为有可能传入一个可变的版本，此时能保证属性值不会受外界影响。
>
> 注意：若用strong修饰NSArray，当数组接收一个可变数组，可变数组若发生变化，被修饰的属性数组也会发生变化，也就是说属性值容易被篡改；若用copy修饰NSMutableArray，当试图修改属性数组里的值时，程序会崩溃，因为数组被复制成了一个不可变的版本。
>
> > 延伸： [深浅copy](./Foundation/Foundation-浅拷贝与深拷贝.md)

> 2. assign、weak、unsafe_unretain区别?
>
>    unsafe_unretained 和 weak一样，表示的是对象的一种弱引用关系。assign只能修饰基本数据类型；
>
>    unsafe_unretained 和 weak的区别是：weak修饰的对象被释放后，指向对象的指针会置空，也就是指向nil,不会产生野指针；而unsafe_unretained修饰的对象被释放后，指针不会置空，而是变成一个野指针，那么此时如果访问这个对象的话，程序就会Crash，抛出BAD_ACCESS的异常。
>
>    > 2.1 那为什么有weak还要用unsafe_unretained呢？
>    >
>    > 答： 1️⃣. __weak只支持iOS 5.0和OS X Mountain Lion作为部署版本（当然对于现在，这个原因已经可以无视了）__
>    >
>    > 2️⃣.__weak对性能会有一定的消耗，使用__weak,需要检查对象是否被释放，在追踪是否被释放的时候当然需要追踪一些信息，那么此时__unsafe_unretained比__weak快，而且一个对象有大量的__weak引用对象的时候，当对象被废弃，那么此时就要遍历weak表，把表里所有的指针置空，消耗cpu资源。__
>    >
>    > 2.2 那么什么时候使用__unsafe_unretained呢？__
>    >
>    > __答： 当你明确对象的生命周期的时候，可以使用__unsafe_unretained替代__weak,可以稍微提高一些性能，虽然这点性能微乎其微。__
>    >
>    > __举个例子，当A拥有B对象，A消亡B也消亡，这样当B存在，A也一定会存在的时候，此时B要调用A的接口，就可以通过__unsafe_unretained 保持对A的引用关系。
>    >
>    > 比如 MyViewController 拥有 MyView, MyView 需要调用 MyViewController 的接口。MyView 中就可以通过 __unsafe_unretained 保持对MyViewController的引用。__
>    >
>    > unsafe_unretained MyViewController * myVC;

#### 4.指定setter 、getter

<> 中为方法名，通过此特质来指定存取方法的名称

```objective-c
//.h文件
@interface MyClass : NSObject
@property (nonatomic, assign, getter=isOn) BOOL on;
@end

//.m文件
@implementation MyClass
- (BOOL)isOn {
    return self.on;
}
@end
```

> 延伸
>
> 我们已经知道 @property 会使编译器自动编写访问这些属性所需的方法，此过程在编译期完成，称为 自动合成 (autosynthesis)。与此相关的还有两个关键词：@dynamic 和 @synthesize。
>
> @dynamic：告诉编译器不要自动创建实现属性所用的实例变量，也不要为其创建存取方法。即使编译器发现没有定义存取方法也不会报错，运行期会导致崩溃。
>
> @synthesize：在类的实现文件里可以通过 @synthesize 指定实例变量的名称。
>
> 注意：在Xcode4.4之前，@property 配合 @synthesize使用，@property 负责声明属性，@synthesize 负责让编译器生成 带下划线的实例变量并且自动生成setter、getter方法。Xcode4.4 之后 @property 得到增强，直接一并替代了 @synthesize 的工作。

## 2. __weak指针的释放过程？

引申： 对象的释放过程

1. 在全局的SideTables中，以this指针为key，找到对应的SideTable
2. `weak_clear_no_lock(weak_table_t *weak_table, id referent_id)`找到referent在weak_table中对应的weak_entry_t.
3. 通过weak_entry_t找出weak引用referent的weak 指针地址数组以及数组长度
4. 遍历这个数组，判断数组元素所指向内容是否与referent匹配，如果匹配将该元素的地址置为nil；如果不匹配，这可能是由于runtime代码的逻辑错误引起的，报错；
5. 待数组中的所有元素指向nil后，需要把当前这个weak_entry_t从weak_table中移除; ----- over

## 3.什么情况下使用copy修饰符？



## 4.为什么block一般使用copy修饰符进行修饰？用strong行不行？

## 5.block内部的结构是怎样的

## 6.为什么使用block容易产生循环引用

## 7.消息转发的过程是怎样的？都涉及了哪些方法？分别是做什么的？

## 8.能结合类对象的数据结构，说一下方法查找的过程吗？

## 9.你理解的runloop是用来做什么的？

## 10.runloop的运行过程是怎样的

## 11。利用runloop检测卡顿有了解吗

## 12.触摸响应事件在控件间的传递查找过程能简单介绍一下吗

## 13HTTPS与HTTP的区别是什么？能简单介绍一下HTTPS的连接过程吗

## 14.说一下项目中的亮点

## 15.二叉树层序遍历，分组打印
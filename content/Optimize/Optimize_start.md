# 启动优化

Apple 官方的[《WWDC Optimizing App Startup Time》](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2016%2F406) 将 iOS 应用的启动可分为 pre-main 阶段和 main 两个阶段，最佳的启动速度是400ms以内，最慢不得大于20s，否则会被系统进程杀死（最低配置设备）。

为了更好的区分，笔者将整个启动流程分为三个阶段， **App总启动流程 = pre-main + main函数代理（didFinishLaunchingWithOptions）+ 首屏渲染（viewDidAppear）**，后两个阶段都属于 `main函数`  执行阶段。

## 1. 启动流程分析

### 1.1 pre-main阶段：

此时对应的 App 页面是闪屏页的展示。

- 加载可执行文件

  加载 `Mach-O` 格式文件，既 App 中所有类编译后生成的格式为 `.o` 的目标文件集合。

- 加载动态库

  `dyld` 加载 `dylib` 会完成如下步骤：

  1. 分析 App 依赖的所有 dylib。
  2. 找到 dylib 对应的 Mach-O 文件。
  3. 打开、读取这些 Mach-O 文件，并验证其有效性。
  4. 在系统内核中注册代码签名。
  5. 对 dylib 的每一个 segment 调用 mmap()。

  系统依赖的动态库由于被优化过，可以较快的加载完成，而开发者引入的动态库需要耗时较久。

- Rebase和Bind操作

  由于使用了`ASLR` 技术，在 `dylib` 加载过程中，需要计算指针偏移得到正确的资源地址。 `Rebase` 将镜像读入内存，修正镜像内部的指针，消耗 `IO` 性能；`Bind` 查询符号表，进行外部镜像的绑定，需要大量 `CPU` 计算。

- Objc setup

  进行 `Objc` 的初始化，包括注册 `Objc` 类、检测 `selector` 唯一性、插入分类方法等。

- Initializers

  往应用的堆栈中写入内容，包括执行 `+load` 方法、调用 `C/C++` 中的构造器函数（用 `attribute((constructor))` 修饰的函数）、创建非基本类型的 `C++` 静态全局变量等。

### 1.2 main阶段：

从 `main()` 函数开始执行到 `didFinishLaunchingWithOptions` 方法执行结束的耗时。通常会在这个过程中进行各种工具（监控工具、推送、定位等）初始化、权限申请、判断版本、全局配置等。

### 1.3 首屏渲染阶段：

首屏 `UI` 构建阶段，需要 `CPU` 计算布局并由 `GPU` 完成渲染，如果数据来源于网络，还需进行网络请求。

## 优化

### 2.1 pre-main阶段

* 合并动态库，并减少使用 `Embedded Framework`，即非系统创建的动态 Framework，如果对包体积要求不严格还可以使用静态库代替。
* 删除无用代码（未使用的静态变量、类和方法等）并抽取重复代码。
* 避免在 `+load` 执行方法，使用 `+initialize` 代替。
* 避免使用 `attribute((constructor))`，可将要实现的内容放在初始化方法中配合 `dispatch_once` 使用。
* 减少非基本类型的 C++ 静态全局变量的个数。（因为这类全局变量通常是类或者结构体，如果在构造函数中有繁重的工作，就会拖慢启动速度）

### 2.2main阶段

- 通过检测工具找到耗时多的函数，拆分其功能，将优先级低的功能延后执行。
- 梳理业务逻辑，把可以延迟执行的逻辑，做延迟执行处理。比如检查新版本、注册推送通知等逻辑。
- 梳理各个二方/三方库，找到可以延迟加载的库，做延迟加载处理，比如放到首页控制器的viewDidAppear方法后。

### 2.3 首屏渲染阶段

- 使用简单的广告页作为过渡，将首页的计算操作及网络请求放在广告页展示时异步进行。
- 涉及活动需变更页面展示时（例如双十一），提前下发数据缓存。
- 首页控制器用纯代码方式来构建，而不是 `xib/Storyboard`，避免布局转换耗时。
- 避免在主线程进行大量的计算，将与首屏无关的计算内容放在页面展示后进行，缩短 `CPU` 计算时间。
- 避免使用大图片，减少视图数量及层级，减轻 `GPU` 的负担。
- 做好网络请求接口优化（DNS 策略等），只请求与首屏相关数据。
- 本地缓存首屏数据，待渲染完成后再去请求新数据。

## 3. 实践结论：

### 3.1 我们根据业务场景将这些事件进行梳理以及分级

#### 3.1.1 移除无用的逻辑

#### 3.1.2 将事件进行分级

根据优先级划分四个档次：

- 第一档： 在App启动阶段，`didFinish`方法里触发。 比如：初始化友盟，初始化热修复，拉取配置等
- 第二档： 首页`didLoad`时候触发调用。 比如：全局UI调整，加载皮肤等
- 第三档： 首页`didAppear`时候触发调用。 比如：上报相关日志，获取iap相关信息等
- 第四档： 首页`出现3s`时候触发调用。比如：预加载其他模块数据等

这样处理后，其实并没有明显的效果，只是业务上更加清晰。

### 3.2 启动事件异步初始化

##### 既然有些东西不得不在启动阶段就去做，是否可以考虑对那些和UI无关的初始化事件放在子线程里去做？只要不卡主线程，启动时间就节省下来了

###### 启动阶段创建一个串行队列，将所有不需要放到主线程操作的事件都放在这个串行队列里异步执行。比如：友盟，广告sdk，carplay，归因等事件



这样操作后，效果很明显。在当时测试情况下，启动阶段几乎不怎么耗时。通过真机运行发现这一步节省了800ms左右 。

链接：https://juejin.cn/post/7002432738162638861


# （附）检测方法：

链接：https://juejin.cn/post/6844904127068110862

### 1. Pre-main阶段 启动耗时的测量

对于pre-main阶段，Apple提供了一种测量方法，在 Xcode 中 Edit scheme -> Run -> Auguments 将环境变量`DYLD_PRINT_STATISTICS `设为`1` ，或者是`DYLD_PRINT_STATISTICS_DETAILS `设为`1`：

### 2. main函数代理阶段

* 手动插入代码计算耗时

* Time Profiler

  `Xcode`自带的工具，原理是定时抓取线程的堆栈信息，通过统计比较时间间隔之间的堆栈状态，计算一段时间内各个方法的近似耗时。精确度取决于设置的定时间隔。

  通过 Xcode → Open Developer Tool → Instruments → Time Profiler 打开工具，注意，需将工程中 Debug Information Format 的 Debug 值改为 DWARF with dSYM File，否则只能看到一堆线程无法定位到函数。

* App Launch

  Xcode11 之后新出的工具，功能相当于 Time Profiler 和 System Trace 的整合。

* Hook  objc_msgSend

  可以对 objc_msgSend 进行 Hook 获取每个函数的具体耗时，优化在启动阶段耗时多的函数或将其置后调用。实现方法可查看笔者之前的文章 [通过objc_msgSend实现iOS方法耗时监控](https://juejin.cn/post/6844904097338884104)。

### 3.首屏渲染阶段

#### 检测方法

记录首屏 `viewDidLoad` 开始时间和`viewDidAppear` 开始时间，两者的差值即为整个首屏渲染耗时，如果要获得具体每个步骤耗时，则可同main函数代理阶段使用 `Time Profiler` 或 `Hook objc_msgSend`。




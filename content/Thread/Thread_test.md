## 1. 线程与进程的区别

> - 地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间；
> - 资源拥有：进程是资源分配和拥有的单位，同一个进程内的线程共享进程里的资源，如内存、I/O、CPU等，但是进程之间的资源是独立的；
> - 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮；
> - 进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程；
> - 执行过程：每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制；
> - 线程是处理器调度的基本单位，但是进程不是；
> - 多进程，允许多个任务同时运行；多线程，允许单个任务分为不同的部分运行。

## 2. 为什么要在主线程更新UI？

> 安全+效率：因为 UIKit 框架不是线程安全的框架，当在多个线程进行 UI 操作，有可能出现资源抢夺，导致问题。
>

## 3. 线程与RunLoop的关系

> 从苹果官方文档可以看到，`RunLoop`的相关介绍写在线程编程指南中，可见`RunLoop`和线程的关系不一般。
>
> - `RunLoop`对象和线程是一一对应关系
> - `RunLoop`保存在一个全局的`Dictionary`里，线程作为`key`，`RunLoop`作为`value`
> - `RunLoop`创建时机：线程刚创建时并没有`RunLoop`对象，`RunLoop`会在第一次获取它时创建
> - `RunLoop`销毁时机：`RunLoop`会在线程结束时销毁
> - 主线程的`RunLoop`已经自动获取（创建），子线程默认没有开启`RunLoop`
> - 主线程的`RunLoop`对象是在`UIApplicationMain`中通过`[NSRunLoop currentRunLoop]`获取，一旦发现它不存在，就会创建`RunLoop`对象

## 4. 以下代码有没有问题？如果没有问题下面运行结果是什么？

```objective-c
@interface ViewController ()
@property (nonatomic, strong) NSString *string;

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    self.view.backgroundColor = [UIColor whiteColor];
    
    dispatch_queue_t queue = dispatch_queue_create("com.yuli.gcd.dispatch_queue", DISPATCH_QUEUE_CONCURRENT);
    for (int i = 1; i <= 100000; i++) {
        
        dispatch_async(queue, ^{
            self.string = [NSString stringWithFormat:@"test_%d",i];
            NSLog(@"self.string: %@",self.string);
        });
        
    }
}
@end

```

> 答：
>
> 两个问题：
>
> 1. `nonatomic`修饰代表非原子性，多线程修改时，因为setter方法内部会对旧值release,可能会造成旧值的过度释放造成崩溃；
> 2. 因为是async多线程异步操作，for循环结束时，最终值具有不确定性

## 5. 同步任务和异步任务的区别

> 两者的主要区别是：**是否等待队列的任务执行结束，以及是否具备开启新线程的能力。**

**任务**：就是执行操作的意思，换句话说就是你在线程中执行的那段代码。在 GCD 中是放在 block 中的。执行任务有两种方式：**『同步执行』** 和 **『异步执行』**。两者的主要区别是：**是否等待队列的任务执行结束，以及是否具备开启新线程的能力。**

- 同步执行（sync）：
  - 同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。
  - 只能在当前线程中执行任务，不具备开启新线程的能力。
- 异步执行（async）：
  - 异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。
  - 可以在新的线程中执行任务，具备开启新线程的能力。

## 6. 串行队列和并发队列的区别

> 在 GCD 中有两种队列：**『串行队列』** 和 **『并发队列』**。两者都符合 FIFO（先进先出）的原则。
>
> 两者的主要区别是：**执行顺序不同，以及开启线程数不同。**
>
> - 串行队列（Serial Dispatch Queue）：
>
>   - 每次只有一个任务被执行。让任务一个接着一个地执行。（只开启一个线程，一个任务执行完毕后，再执行下一个任务）
>
> - 并发队列（Concurrent Dispatch Queue）：
>
>   - 可以让多个任务并发（同时）执行。（可以开启多个线程，并且同时执行任务）
>
> > 注意：**并发队列** 的并发功能只有在异步（dispatch_async）方法下才有效。
>
> > 引自维基百科[队列](https://links.jianshu.com/go?to=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F队列)，又称为伫列（queue），是先进先出（FIFO, First-In-First-Out）的线性表。
> >
> > 在具体应用中通常用链表或者数组来实现。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。 队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。
>
> <font color='red'>这里会有一个经常性的疑问，串行队列一次执行一个任务，任务按顺序执行，先进先出，这个好理解。**那并发队列几个任务同时执行也是先进先出，这个怎么理解呢。因为并发执行任务，先进去的任务并不一定先执行完，但是即使后面的任务先执行完，也是要等前面的任务退出。这是由队列的性质决定的。**</font>

**队列（Dispatch Queue）**：这里的队列指执行任务的等待队列，即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。队列的结构可参考下图：

![img](file:///Users/tangh/yuki/%E5%8D%9A%E5%AE%A2/%E6%96%87%E7%AB%A0%E4%BB%93%E5%BA%93/YLNoteHub/content/Thread/image/Thread_base_0.png?lastModify=1645100015)



注意几个考察点，尤其是出现嵌套的复杂场景：

- 多个同步任务加入串行队列 （注意：此情况下并没有开辟新的线程，而是使用的当前线程。）
- 多个异步任务加入串行队列 （会开启新的线程）
- 多个同步任务加入并发队列
- 多个异步任务加入并发队列

总结：

1. 在串行队列中的任务中，再嵌套同一队列的同步任务，一定会死锁，崩溃；
2. 异步任务一般都会开启新的线程，例外：放入主队列的异步任务只能在主线程执行（<font color='red'> dispatch_async一定会开启新线程吗 </font>）



> > 概念解释：
> >
> > **阻塞与非阻塞**
> >
> > 阻塞/非阻塞， 它们是程序在等待消息(无所谓同步或者异步)时的状态。
> >
> > **A、阻塞**
> >
> > 阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。
> >
> > socket 接收数据函数 recv 是一个阻塞调用的例子。当 socket 工作在阻塞模式的时候， 如果没有数据的情况下调用该函数，则当前线程就会被挂起，直到有数据为止。
> >
> > **B、非阻塞**
> >
> > 非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。
> >
> > **C、对象的阻塞模式和阻塞函数调用**
> >
> > 对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但是并不是一一对应的。阻塞对象上可以有非阻塞的调用方式，我们可以通过一定的 API 去轮询状态，在适当的时候调用阻塞函数，就可以避免阻塞。而对于非阻塞对象，调用特殊的函数也可以进入阻塞调用。函数 select 就是这样的一个例子

## 7. 常用的多线程有哪几种？

>  NSThread、NSOperation、GCD

## 8. Operation 与 GCD 的区别？ 

> - **1.** GCD 的核心是 C 语言写的系统服务，执行和操作简单高效，因此 NSOperation 底层也通过 GCD 实现，换个说法就是 NSOperation 是对 GCD 更高层次的抽象，这是他们之间最本质的区别。因此如果希望自定义任务，建议使用 NSOperation；
> - **2.** 依赖关系，NSOperation 可以设置两个 NSOperation 之间的依赖，第二个任务依赖于第一个任务完成执行，GCD 无法设置依赖关系，不过可以通过dispatch_barrier_async来实现这种效果；
> - **3.** KVO(键值对观察)，NSOperation 和容易判断 Operation 当前的状态(是否执行，是否取消)，对此 GCD 无法通过 KVO 进行判断；
> - **4.** 优先级，NSOperation 可以设置自身的优先级，但是优先级高的不一定先执行，GCD 只能设置队列的优先级，无法在执行的 block 设置优先级；
> - **5.** 继承，NSOperation 是一个抽象类，实际开发中常用的两个类是 NSInvocationOperation 和 NSBlockOperation ，同样我们可以自定义 NSOperation，GCD 执行任务可以自由组装，没有继承那么高的代码复用度；
> - **6.** 效率，直接使用 GCD 效率确实会更高效，NSOperation 会多一点开销，但是通过 NSOperation 可以获得依赖，优先级，继承，键值对观察这些优势，相对于多的那么一点开销确实很划算，鱼和熊掌不可得兼，取舍在于开发者自己；

## 9. GCD 下怎么实现 dependents ?
